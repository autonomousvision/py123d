from pathlib import Path
from typing import List, Optional, Type, Union

import numpy as np
import numpy.typing as npt
import pyarrow as pa

from py123d.common.dataset_paths import get_dataset_paths
from py123d.common.utils.arrow_column_names import (
    BOX_DETECTIONS_BOUNDING_BOX_SE3_COLUMN,
    BOX_DETECTIONS_LABEL_COLUMN,
    BOX_DETECTIONS_NUM_LIDAR_POINTS_COLUMN,
    BOX_DETECTIONS_SE3_COLUMNS,
    BOX_DETECTIONS_TOKEN_COLUMN,
    BOX_DETECTIONS_VELOCITY_3D_COLUMN,
    EGO_DYNAMIC_STATE_SE3_COLUMN,
    EGO_REAR_AXLE_SE3_COLUMN,
    EGO_STATE_SE3_COLUMNS,
    FISHEYE_CAMERA_DATA_COLUMN,
    FISHEYE_CAMERA_EXTRINSIC_COLUMN,
    FISHEYE_CAMERA_TIMESTAMP_COLUMN,
    LIDAR_PATH_COLUMN,
    LIDAR_POINT_CLOUD_COLUMN,
    LIDAR_POINT_CLOUD_FEATURE_COLUMN,
    PINHOLE_CAMERA_DATA_COLUMN,
    PINHOLE_CAMERA_EXTRINSIC_COLUMN,
    PINHOLE_CAMERA_TIMESTAMP_COLUMN,
    ROUTE_LANE_GROUP_IDS_COLUMN,
    SCENARIO_TAGS_COLUMN,
    TIMESTAMP_US_COLUMN,
    TRAFFIC_LIGHTS_COLUMNS,
    TRAFFIC_LIGHTS_LANE_ID_COLUMN,
    TRAFFIC_LIGHTS_STATUS_COLUMN,
)
from py123d.common.utils.mixin import ArrayMixin
from py123d.common.utils.msgpack_utils import decode_features_from_binary, msgpack_decode_with_numpy
from py123d.conversion.registry import DefaultLidarIndex
from py123d.conversion.sensor_io.camera.jpeg_camera_io import (
    decode_image_from_jpeg_binary,
    is_jpeg_binary,
    load_image_from_jpeg_file,
)
from py123d.conversion.sensor_io.camera.mp4_camera_io import get_mp4_reader_from_path
from py123d.conversion.sensor_io.camera.png_camera_io import decode_image_from_png_binary, is_png_binary
from py123d.conversion.sensor_io.lidar.draco_lidar_io import is_draco_binary, load_lidar_from_draco_binary
from py123d.conversion.sensor_io.lidar.laz_lidar_io import is_laz_binary, load_lidar_from_laz_binary
from py123d.conversion.sensor_io.lidar.path_lidar_io import load_point_cloud_data_from_path
from py123d.datatypes.detections import (
    BoxDetectionMetadata,
    BoxDetectionSE3,
    BoxDetectionWrapper,
    TrafficLightDetection,
    TrafficLightDetectionWrapper,
    TrafficLightStatus,
)
from py123d.datatypes.metadata import LogMetadata
from py123d.datatypes.sensors import (
    FisheyeMEICamera,
    FisheyeMEICameraID,
    Lidar,
    LidarID,
    LidarMetadata,
    PinholeCamera,
    PinholeCameraID,
)
from py123d.datatypes.time import Timestamp
from py123d.datatypes.vehicle_state import DynamicStateSE3, EgoStateSE3, VehicleParameters
from py123d.geometry import BoundingBoxSE3, PoseSE3, Vector3D


def get_timestamp_from_arrow_table(arrow_table: pa.Table, index: int) -> Timestamp:
    """Builds a :class:`~py123d.datatypes.time.TimePoint` from an Arrow table at a given index.

    :param arrow_table: The Arrow table containing the timestamp data.
    :param index: The index to extract the timestamp from.
    :return: The TimePoint at the given index.
    """
    assert TIMESTAMP_US_COLUMN in arrow_table.schema.names, "Timestamp column not found in Arrow table."
    return Timestamp.from_us(arrow_table[TIMESTAMP_US_COLUMN][index].as_py())


def get_ego_state_se3_from_arrow_table(
    arrow_table: pa.Table,
    index: int,
    vehicle_parameters: Optional[VehicleParameters],
) -> Optional[EgoStateSE3]:
    """Builds a :class:`~py123d.datatypes.vehicle_state.EgoStateSE3` from an Arrow table at a given index.

    :param arrow_table: The Arrow table containing the ego state data.
    :param index: The index to extract the ego state from.
    :param vehicle_parameters: The vehicle parameters used to build the ego state.
    :return: The ego state at the given index, or None if not available.
    """

    ego_state_se3: Optional[EgoStateSE3] = None
    if _all_columns_in_schema(arrow_table, EGO_STATE_SE3_COLUMNS) and vehicle_parameters is not None:
        timestamp = get_timestamp_from_arrow_table(arrow_table, index)
        rear_axle_se3 = PoseSE3.from_list(arrow_table[EGO_REAR_AXLE_SE3_COLUMN][index].as_py())
        dynamic_state_se3 = _get_optional_array_mixin(
            arrow_table[EGO_DYNAMIC_STATE_SE3_COLUMN][index].as_py(),
            DynamicStateSE3,
        )
        ego_state_se3 = EgoStateSE3.from_rear_axle(
            rear_axle_se3=rear_axle_se3,
            vehicle_parameters=vehicle_parameters,
            dynamic_state_se3=dynamic_state_se3,
            timestamp=timestamp,
        )
    return ego_state_se3


def get_box_detections_se3_from_arrow_table(
    arrow_table: pa.Table,
    index: int,
    log_metadata: LogMetadata,
) -> BoxDetectionWrapper:
    """Builds a :class:`~py123d.datatypes.detections.BoxDetectionWrapper` from an Arrow table at a given index.

    :param arrow_table: The Arrow table containing the box detections data.
    :param index: The index to extract the box detections from.
    :param log_metadata: The log metadata, contained the label class information.
    :return: The BoxDetectionWrapper at the given index.
    """

    box_detections: Optional[BoxDetectionWrapper] = None
    if _all_columns_in_schema(arrow_table, BOX_DETECTIONS_SE3_COLUMNS):
        timestamp = get_timestamp_from_arrow_table(arrow_table, index)
        box_detections_list: List[BoxDetectionSE3] = []
        box_detection_label_class = log_metadata.box_detection_label_class
        assert box_detection_label_class is not None, "Box detection label class mapping not found in log metadata."
        for _bounding_box_se3, _token, _label, _velocity, _num_lidar_points in zip(
            arrow_table[BOX_DETECTIONS_BOUNDING_BOX_SE3_COLUMN][index].as_py(),
            arrow_table[BOX_DETECTIONS_TOKEN_COLUMN][index].as_py(),
            arrow_table[BOX_DETECTIONS_LABEL_COLUMN][index].as_py(),
            arrow_table[BOX_DETECTIONS_VELOCITY_3D_COLUMN][index].as_py(),
            arrow_table[BOX_DETECTIONS_NUM_LIDAR_POINTS_COLUMN][index].as_py(),
        ):
            box_detections_list.append(
                BoxDetectionSE3(
                    metadata=BoxDetectionMetadata(
                        label=box_detection_label_class(_label),
                        track_token=_token,
                        num_lidar_points=_num_lidar_points,
                        timestamp=timestamp,
                    ),
                    bounding_box_se3=BoundingBoxSE3.from_list(_bounding_box_se3),
                    velocity_3d=_get_optional_array_mixin(_velocity, Vector3D),
                )
            )
        box_detections = BoxDetectionWrapper(box_detections=box_detections_list)

    return box_detections


def get_traffic_light_detections_from_arrow_table(
    arrow_table: pa.Table,
    index: int,
) -> Optional[TrafficLightDetectionWrapper]:
    """Builds a :class:`~py123d.datatypes.detections.TrafficLightDetectionWrapper` from an Arrow table at a given index.

    :param arrow_table: The Arrow table containing the traffic light detections data.
    :param index: The index to extract the traffic light detections from.
    :return: The TrafficLightDetectionWrapper at the given index, or None if not available.
    """
    traffic_lights: Optional[TrafficLightDetectionWrapper] = None
    if _all_columns_in_schema(arrow_table, TRAFFIC_LIGHTS_COLUMNS):
        timestamp = get_timestamp_from_arrow_table(arrow_table, index)
        traffic_light_detections: List[TrafficLightDetection] = []
        for lane_id, status in zip(
            arrow_table[TRAFFIC_LIGHTS_LANE_ID_COLUMN][index].as_py(),
            arrow_table[TRAFFIC_LIGHTS_STATUS_COLUMN][index].as_py(),
        ):
            traffic_light_detections.append(
                TrafficLightDetection(
                    timestamp=timestamp,
                    lane_id=lane_id,
                    status=TrafficLightStatus(status),
                )
            )
        traffic_lights = TrafficLightDetectionWrapper(traffic_light_detections=traffic_light_detections)
    return traffic_lights


def get_camera_from_arrow_table(
    arrow_table: pa.Table,
    index: int,
    camera_type: Union[PinholeCameraID, FisheyeMEICameraID],
    log_metadata: LogMetadata,
) -> Optional[Union[PinholeCamera, FisheyeMEICamera]]:
    """Builds a camera object from an Arrow table at a given index.

    :param arrow_table: The Arrow table containing the camera data.
    :param index: The index to extract the camera data from.
    :param camera_type: The type of camera to build (Pinhole or FisheyeMEI).
    :param log_metadata: Metadata about the log, including dataset information.
    :raises ValueError: If the camera data format is unsupported.
    :raises NotImplementedError: If the camera data type is not supported.
    :return: The constructed camera object, or None if not available.
    """

    assert isinstance(camera_type, (PinholeCameraID, FisheyeMEICameraID)), (
        f"camera_type must be PinholeCameraID or FisheyeMEICameraType, got {type(camera_type)}"
    )

    camera: Optional[Union[PinholeCamera, FisheyeMEICamera]] = None

    camera_name = camera_type.serialize()
    is_pinhole = isinstance(camera_type, PinholeCameraID)

    if is_pinhole:
        camera_data_column = PINHOLE_CAMERA_DATA_COLUMN(camera_name)
        camera_extrinsic_column = PINHOLE_CAMERA_EXTRINSIC_COLUMN(camera_name)
        camera_timestamp_column = PINHOLE_CAMERA_TIMESTAMP_COLUMN(camera_name)
    else:
        camera_data_column = FISHEYE_CAMERA_DATA_COLUMN(camera_name)
        camera_extrinsic_column = FISHEYE_CAMERA_EXTRINSIC_COLUMN(camera_name)
        camera_timestamp_column = FISHEYE_CAMERA_TIMESTAMP_COLUMN(camera_name)

    if _all_columns_in_schema(arrow_table, [camera_data_column, camera_extrinsic_column, camera_timestamp_column]):
        table_data = arrow_table[camera_data_column][index].as_py()
        extrinsic_data = arrow_table[camera_extrinsic_column][index].as_py()
        timestamp_data = arrow_table[camera_timestamp_column][index].as_py()

        if table_data is not None and extrinsic_data is not None:
            extrinsic = PoseSE3.from_list(extrinsic_data)
            image: Optional[npt.NDArray[np.uint8]] = None

            if isinstance(table_data, str):
                sensor_root = get_dataset_paths().get_sensor_root(log_metadata.dataset)
                assert sensor_root is not None, (
                    f"Dataset path for sensor loading not found for dataset: {log_metadata.dataset}"
                )
                full_image_path = Path(sensor_root) / table_data
                assert full_image_path.exists(), f"Camera file not found: {full_image_path}"

                image = load_image_from_jpeg_file(full_image_path)
            elif isinstance(table_data, bytes):
                if is_jpeg_binary(table_data):
                    image = decode_image_from_jpeg_binary(table_data)
                elif is_png_binary(table_data):
                    image = decode_image_from_png_binary(table_data)
                else:
                    raise ValueError("Camera binary data is neither in JPEG nor PNG format.")

            elif isinstance(table_data, int):
                image = _unoptimized_demo_mp4_read(log_metadata, camera_name, table_data)
            else:
                raise NotImplementedError(
                    f"Only string file paths, bytes, or int frame indices are supported for camera data, got {type(table_data)}"
                )

            if is_pinhole:
                camera_metadata = log_metadata.pinhole_camera_metadata[camera_type]
                camera = PinholeCamera(
                    metadata=camera_metadata,
                    image=image,
                    extrinsic=extrinsic,
                    timestamp=Timestamp.from_us(timestamp_data),
                )
            else:
                camera_metadata = log_metadata.fisheye_mei_camera_metadata[camera_type]
                camera = FisheyeMEICamera(
                    metadata=camera_metadata,
                    image=image,
                    extrinsic=extrinsic,
                    timestamp=Timestamp.from_us(timestamp_data),
                )

    return camera


def get_camera_timestamp_from_arrow_table(
    arrow_table: pa.Table,
    index: int,
    camera_type: Union[PinholeCameraID, FisheyeMEICameraID],
) -> Optional[Timestamp]:
    """Gets the camera timestamp from an Arrow table at a given index.

    :param arrow_table: The Arrow table containing the camera timestamp data.
    :param index: The index to extract the camera timestamp from.
    :param camera_type: The type of camera (Pinhole or FisheyeMEI).
    :return: The camera timestamp at the given index, or None if not available.
    """

    assert isinstance(camera_type, (PinholeCameraID, FisheyeMEICameraID)), (
        f"camera_type must be PinholeCameraID or FisheyeMEICameraType, got {type(camera_type)}"
    )

    camera_timestamp: Optional[Timestamp] = None
    camera_name = camera_type.serialize()

    if isinstance(camera_type, PinholeCameraID):
        camera_timestamp_column = PINHOLE_CAMERA_TIMESTAMP_COLUMN(camera_name)
    else:
        camera_timestamp_column = FISHEYE_CAMERA_TIMESTAMP_COLUMN(camera_name)

    if camera_timestamp_column in arrow_table.schema.names:
        timestamp_data = arrow_table[camera_timestamp_column][index].as_py()
        if timestamp_data is not None:
            camera_timestamp = Timestamp.from_us(timestamp_data)

    return camera_timestamp


def get_lidar_from_arrow_table(
    arrow_table: pa.Table,
    index: int,
    lidar_type: LidarID,
    log_metadata: LogMetadata,
) -> Lidar:
    """Builds a Lidar object from an Arrow table at a given index.

    :param arrow_table: The Arrow table containing the Lidar data.
    :param index: The index to extract the Lidar data from.
    :param lidar_type: The type of Lidar to build.
    :param log_metadata: Metadata about the log, including the Lidar metadata.
    :raises ValueError: If the Lidar data format is unsupported.
    :raises NotImplementedError: If the Lidar data type is not supported.
    :return: The constructed Lidar object, or None if not available.
    """
    lidar_point_cloud = None
    lidar_point_cloud_feature = None
    if LIDAR_PATH_COLUMN(LidarID.LIDAR_MERGED.serialize()) in arrow_table.schema.names:
        # 1. Load lidar sweep from origin dataset using a relative file path.
        lidar_data = arrow_table[LIDAR_PATH_COLUMN(LidarID.LIDAR_MERGED.serialize())][index].as_py()
        if lidar_data is not None:
            assert isinstance(lidar_data, str), f"Lidar path data must be a string file path, got {type(lidar_data)}"
            lidar_point_cloud, lidar_point_cloud_feature = load_point_cloud_data_from_path(
                relative_path=lidar_data, log_metadata=log_metadata, index=index
            )

    elif LIDAR_POINT_CLOUD_COLUMN(LidarID.LIDAR_MERGED.serialize()) in arrow_table.schema.names:
        # 2.1 Loading the lidar xyz point cloud from blob in the Arrow table.
        lidar_data = arrow_table[LIDAR_POINT_CLOUD_COLUMN(LidarID.LIDAR_MERGED.serialize())][index].as_py()
        if is_draco_binary(lidar_data):
            lidar_point_cloud = load_lidar_from_draco_binary(lidar_data)
        elif is_laz_binary(lidar_data):
            lidar_point_cloud = load_lidar_from_laz_binary(lidar_data)
        else:
            lidar_point_cloud_dict = decode_features_from_binary(lidar_data)
            lidar_point_cloud = np.concatenate(
                [
                    lidar_point_cloud_dict["x"].reshape(-1, 1),
                    lidar_point_cloud_dict["y"].reshape(-1, 1),
                    lidar_point_cloud_dict["z"].reshape(-1, 1),
                ],
                axis=1,
            ).astype(np.float32)

        # 2.1 Load lidar features from blob in the Arrow table, if available.
        if LIDAR_POINT_CLOUD_FEATURE_COLUMN(LidarID.LIDAR_MERGED.serialize()) in arrow_table.schema.names:
            lidar_point_cloud_feature_data = arrow_table[
                LIDAR_POINT_CLOUD_FEATURE_COLUMN(LidarID.LIDAR_MERGED.serialize())
            ][index].as_py()
            if lidar_point_cloud_feature_data is not None:
                lidar_point_cloud_feature = msgpack_decode_with_numpy(lidar_point_cloud_feature_data)

    lidar: Optional[Lidar] = None
    if lidar_point_cloud is not None:
        if lidar_type != LidarID.LIDAR_MERGED:
            if lidar_point_cloud_feature is not None and "lidar_id" in lidar_point_cloud_feature.keys():
                mask = lidar_point_cloud_feature["lidar_id"] == int(lidar_type.value)
                lidar_point_cloud_feature = {key: value[mask] for key, value in lidar_point_cloud_feature.items()}
                lidar_point_cloud = lidar_point_cloud[mask]
                lidar = Lidar(
                    metadata=log_metadata.lidar_metadata[lidar_type],
                    point_cloud_3d=lidar_point_cloud,
                    point_cloud_features=lidar_point_cloud_feature,
                )
        else:
            lidar = Lidar(
                metadata=LidarMetadata(
                    lidar_name=LidarID.LIDAR_MERGED.serialize(),
                    lidar_id=LidarID.LIDAR_MERGED,
                    lidar_index=DefaultLidarIndex,
                    extrinsic=PoseSE3.identity(),
                ),
                point_cloud_3d=lidar_point_cloud,
                point_cloud_features=lidar_point_cloud_feature,
            )

    return lidar


def get_route_lane_group_ids_from_arrow_table(arrow_table: pa.Table, index: int) -> Optional[List[int]]:
    """Gets the route lane group IDs from an Arrow table at a given index.

    :param arrow_table: The Arrow table containing the route lane group IDs data.
    :param index: The index to extract the route lane group IDs from.
    :return: The route lane group IDs at the given index, or None if not available
    """
    route_lane_group_ids: Optional[List[int]] = None
    if _all_columns_in_schema(arrow_table, [ROUTE_LANE_GROUP_IDS_COLUMN]):
        route_lane_group_ids = arrow_table[ROUTE_LANE_GROUP_IDS_COLUMN][index].as_py()
    return route_lane_group_ids


def get_scenario_tags_from_arrow_table(arrow_table: pa.Table, index: int) -> Optional[List[int]]:
    """Gets the scenario tags from an Arrow table at a given index.

    :param arrow_table: The Arrow table containing the scenario tags data.
    :param index: The index to extract the scenario tags from.
    :return: The scenario tags at the given index, or None if not available
    """
    scenario_tags: Optional[List[int]] = None
    if _all_columns_in_schema(arrow_table, [SCENARIO_TAGS_COLUMN]):
        scenario_tags = arrow_table[SCENARIO_TAGS_COLUMN][index].as_py()
    return scenario_tags


def _unoptimized_demo_mp4_read(log_metadata: LogMetadata, camera_name: str, frame_index: int) -> Optional[np.ndarray]:
    """Reads a frame from an MP4 file for demonstration purposes. This features is not optimized for performance.

    :param log_metadata: The metadata of the log containing the MP4 file.
    :param camera_name: The name of the camera whose MP4 file is to be read.
    :param frame_index: The index of the frame to read from the MP4 file.
    :return: The image frame as a numpy array, or None if the file does not exist.
    """
    image: Optional[npt.NDArray[np.uint8]] = None

    py123d_sensor_root = get_dataset_paths().py123d_sensors_root
    assert py123d_sensor_root is not None, "PY123D_DATA_ROOT must be set for MP4 reading."
    mp4_path = py123d_sensor_root / log_metadata.split / log_metadata.log_name / f"{camera_name}.mp4"
    if mp4_path.exists():
        reader = get_mp4_reader_from_path(str(mp4_path))
        image = reader.get_frame(frame_index)

    return image


def _get_optional_array_mixin(data: Optional[Union[List, npt.NDArray]], cls: Type[ArrayMixin]) -> Optional[ArrayMixin]:
    """Builds an optional ArrayMixin if data is provided.

    :param data: The data to convert into an ArrayMixin.
    :param cls: The ArrayMixin class to instantiate.
    :raises ValueError: If the data type is unsupported.
    :return: The instantiated ArrayMixin, or None if data is None.
    """
    if data is None:
        return None
    if isinstance(data, list):
        return cls.from_list(data)
    elif isinstance(data, np.ndarray):
        return cls.from_array(data, copy=False)
    else:
        raise ValueError(f"Unsupported data type for ArrayMixin conversion: {type(data)}")


def _all_columns_in_schema(arrow_table: pa.Table, columns: List[str]) -> bool:
    """Checks if all specified columns are present in the Arrow table schema.

    :param arrow_table: The Arrow table to check.
    :param columns: The list of column names to check for.
    :return: True if all columns are present, False otherwise.
    """
    return all(column in arrow_table.schema.names for column in columns)

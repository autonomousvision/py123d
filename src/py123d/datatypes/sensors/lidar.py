from __future__ import annotations

from typing import Any, Dict, Optional, Type

import numpy as np
import numpy.typing as npt

from py123d.common.utils.enums import SerialIntEnum
from py123d.geometry import Point3DIndex, PoseSE3


class LidarID(SerialIntEnum):
    """Enumeration of Lidar sensors, in multi-sensor setups."""

    LIDAR_UNKNOWN = 0
    """Unknown Lidar type."""

    LIDAR_MERGED = 1
    """Merged Lidar type."""

    LIDAR_TOP = 2
    """Top-facing Lidar type."""

    LIDAR_FRONT = 3
    """Front-facing Lidar type."""

    LIDAR_SIDE_LEFT = 4
    """Left-side Lidar type."""

    LIDAR_SIDE_RIGHT = 5
    """Right-side Lidar type."""

    LIDAR_BACK = 6
    """Back-facing Lidar type."""

    LIDAR_DOWN = 7
    """Down-facing Lidar type."""


class LidarFeature(SerialIntEnum):
    """Enumeration of common Lidar point cloud features"""

    IDS = 0
    """Point IDs feature index."""

    INTENSITY = 1
    """Intensity feature index."""

    CHANNEL = 2
    """Ring feature index."""

    TIMESTAMP = 3
    """Timestamp feature index."""

    RANGE = 4
    """Range feature index."""

    ELONGATION = 5
    """Elongation feature index."""


LIDAR_FEATURE_DTYPES: Dict[LidarFeature, Type] = {
    LidarFeature.IDS: np.uint8,
    LidarFeature.INTENSITY: np.uint8,
    LidarFeature.CHANNEL: np.uint8,
    LidarFeature.TIMESTAMP: np.int64,
    LidarFeature.RANGE: np.float32,
    LidarFeature.ELONGATION: np.float32,
}


class LidarMetadata:
    """Metadata for Lidar sensor, static for a given sensor."""

    __slots__ = ("_lidar_name", "_lidar_id", "_lidar_to_imu_se3")

    def __init__(
        self,
        lidar_name: str,
        lidar_id: LidarID,
        lidar_to_imu_se3: PoseSE3 = PoseSE3.identity(),
    ):
        """Initialize Lidar metadata.

        :param lidar_name: The name of the Lidar sensor from the dataset.
        :param lidar_id: The ID of the Lidar sensor.
        :param lidar_index: The indexing schema of the Lidar point cloud.
        :param lidar_to_imu_se3: The extrinsic pose of the Lidar sensor relative to the IMU
        """
        self._lidar_name = lidar_name
        self._lidar_id = lidar_id
        self._lidar_to_imu_se3 = lidar_to_imu_se3

    @property
    def lidar_name(self) -> str:
        """The name of the Lidar sensor from the dataset."""
        return self._lidar_name

    @property
    def lidar_id(self) -> LidarID:
        """The ID of the Lidar sensor."""
        return self._lidar_id

    @property
    def lidar_to_imu_se3(self) -> PoseSE3:
        """The extrinsic :class:`~py123d.geometry.PoseSE3` of the Lidar sensor, relative to the IMU frame."""
        return self._lidar_to_imu_se3

    @property
    def extrinsic(self) -> PoseSE3:
        """The extrinsic :class:`~py123d.geometry.PoseSE3` of the Lidar sensor, relative to the IMU frame."""
        return self._lidar_to_imu_se3

    @classmethod
    def from_dict(cls, data_dict: dict) -> LidarMetadata:
        """Construct the Lidar metadata from a dictionary.

        :param data_dict: A dictionary containing Lidar metadata.
        :raises ValueError: If the dictionary is missing required fields or contains invalid data.
        :return: An instance of LidarMetadata.
        """
        data_dict["lidar_id"] = LidarID[data_dict["lidar_id"]]
        data_dict["lidar_to_imu_se3"] = PoseSE3.from_list(data_dict["lidar_to_imu_se3"])
        return cls(**data_dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert the Lidar metadata to a dictionary.

        :return: A dictionary representation of the Lidar metadata.
        """
        return {
            "lidar_name": self.lidar_name,
            "lidar_id": self.lidar_id.name,
            "lidar_to_imu_se3": self.lidar_to_imu_se3.tolist(),
        }


class Lidar:
    """Data structure for Lidar point cloud data and associated metadata."""

    __slots__ = ("_metadata", "_point_cloud_3d", "_point_cloud_features")

    def __init__(
        self,
        metadata: LidarMetadata,
        point_cloud_3d: npt.NDArray[np.float32],
        point_cloud_features: Optional[Dict[str, npt.NDArray]] = None,
    ) -> None:
        """Initialize Lidar data structure.

        :param metadata: Lidar metadata.
        :param point_cloud_3d: Lidar point cloud as an NxM numpy array, where N is the number of points
            and M is the number of attributes per point as defined by the :class:`~py123d.conversion.registry.LidarIndex`.
        :param point_cloud_features: Optional dictionary of point cloud features.
        """
        self._metadata = metadata
        self._point_cloud_3d = point_cloud_3d
        self._point_cloud_features = point_cloud_features

    @property
    def metadata(self) -> LidarMetadata:
        """The :class:`LidarMetadata` associated with this Lidar recording."""
        return self._metadata

    @property
    def point_cloud_3d(self) -> npt.NDArray[np.float32]:
        """The raw point cloud as an NxM numpy array,
        where N is the number of points and M is the number of attributes per point,
        as defined by the :class:`~py123d.conversion.registry.LidarIndex`. Point cloud in vehicle frame.
        """
        return self._point_cloud_3d

    @property
    def point_cloud_features(self) -> Optional[Dict[str, npt.NDArray]]:
        """The point cloud features as a dictionary of numpy arrays."""
        return self._point_cloud_features

    @property
    def xyz(self) -> npt.NDArray[np.float32]:
        """The point cloud as an Nx3 array of x, y, z coordinates."""
        return self._point_cloud_3d

    @property
    def xy(self) -> npt.NDArray[np.float32]:
        """The point cloud as an Nx2 array of x, y coordinates."""
        return self._point_cloud_3d[..., Point3DIndex.XY]  # type: ignore

    @property
    def ids(self) -> Optional[npt.NDArray[np.uint8]]:
        """The point cloud as an Nx1 array of point IDs, if available."""
        ids: Optional[npt.NDArray[np.uint8]] = None
        key = LidarFeature.IDS.serialize()
        if self._point_cloud_features is not None and key in self._point_cloud_features:
            ids = self._point_cloud_features[key].astype(np.uint8)  # type: ignore
        return ids

    @property
    def intensity(self) -> Optional[npt.NDArray[np.uint8]]:
        """The point cloud as an Nx1 array of intensity values, if available."""
        intensity: Optional[npt.NDArray[np.uint8]] = None
        key = LidarFeature.INTENSITY.serialize()
        if self._point_cloud_features is not None and key in self._point_cloud_features:
            intensity = self._point_cloud_features[key].astype(np.uint8)  # type: ignore
        return intensity

    @property
    def channel(self) -> Optional[npt.NDArray[np.uint8]]:
        """The point cloud as an Nx1 array of channel/ring values, if available."""
        channel: Optional[npt.NDArray[np.uint8]] = None
        key = LidarFeature.CHANNEL.serialize()
        if self._point_cloud_features is not None and key in self._point_cloud_features:
            channel = self._point_cloud_features[key].astype(np.uint8)  # type: ignore
        return channel

    @property
    def timestamp(self) -> Optional[npt.NDArray[np.int64]]:
        """The point cloud as an Nx1 array of timestamps in microseconds, if available."""
        timestamp: Optional[npt.NDArray[np.int64]] = None
        key = LidarFeature.TIMESTAMP.serialize()
        if self._point_cloud_features is not None and key in self._point_cloud_features:
            timestamp = self._point_cloud_features[key].astype(np.int64)  # type: ignore
        return timestamp

    @property
    def range(self) -> Optional[npt.NDArray[np.float32]]:
        """The point cloud as an Nx1 array of range values, if available."""
        range: Optional[npt.NDArray[np.float32]] = None
        key = LidarFeature.RANGE.serialize()
        if self._point_cloud_features is not None and key in self._point_cloud_features:
            range = self._point_cloud_features[key].astype(np.float32)  # type: ignore
        return range

    @property
    def elongation(self) -> Optional[npt.NDArray[np.float32]]:
        """The point cloud as an Nx1 array of elongation values, if available."""
        elongation: Optional[npt.NDArray[np.float32]] = None
        key = LidarFeature.ELONGATION.serialize()
        if self._point_cloud_features is not None and key in self._point_cloud_features:
            elongation = self._point_cloud_features[key].astype(np.float32)  # type: ignore
        return elongation
